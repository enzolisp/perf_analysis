% Stage 3 - Comp. Sys. Perf Analysis (2025/2) - Lucas M. Schnorr
% Group F: Enzo Lisboa Peixoto - 00584827, Nathan Mattes - 00342941 e Pedro Scholz Soares - 00578266 

\documentclass[acsmall, language=portuguese]{acmart}

%% Pacotes adicionais úteis
\usepackage{booktabs} % Para tabelas bonitas
\usepackage{graphicx} % Para imagens
\usepackage{subcaption} % Para subfiguras

%% Configurações do BibTeX
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\setcopyright{acmlicensed}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}

%% Journal info (pode manter padrão ou remover se não for submeter)
\acmJournal{JACM}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmMonth{11}

\begin{document}

%% Título
\title{Avaliação de Desempenho da Equação do Calor: Uma Análise Comparativa entre Python e Julia}

%% Autores
\author{Enzo Lisbôa Peixoto}
\email{elpeixoto@inf.ufrgs.br}
\affiliation{%
  \institution{Universidade Federal do Rio Grande do Sul}
  \city{Porto Alegre}
  \state{Rio Grande do Sul}
  \country{Brasil}
}

\author{Nathan Mattes}
\email{nmattes@inf.ufrgs.br}
\affiliation{%
  \institution{Universidade Federal do Rio Grande do Sul}
  \city{Porto Alegre}
  \state{Rio Grande do Sul}
  \country{Brasil}
}

\author{Pedro Scholz Soares}
\email{pssoares@inf.ufrgs.br}
\affiliation{%
  \institution{Universidade Federal do Rio Grande do Sul}
  \city{Porto Alegre}
  \state{Rio Grande do Sul}
  \country{Brasil}
}

\renewcommand{\shortauthors}{Peixoto et al.}

%% Resumo
\begin{abstract}
Este trabalho apresenta uma análise de desempenho comparativa entre as linguagens Python e Julia na resolução numérica da Equação do Calor utilizando o Método das Diferenças Finitas em 1D, 2D e 3D. O estudo foi conduzido em um ambiente controlado utilizando contêineres Docker e isolamento de recursos de hardware (CPU Pinning) para garantir a reprodutibilidade. Os resultados demonstram a superioridade de desempenho da linguagem Julia em tarefas intensivas de CPU, com speedups significativos em relação à implementação pura em Python, embora com um consumo de memória superior. A análise estatística, incluindo regressão linear e gráficos de estabilidade, valida o comportamento assintótico esperado dos algoritmos e destaca a importância do controle de ruído do sistema operacional em benchmarks de computação.
\end{abstract}


\ccsdesc[500]{General and reference~Measurement}
\ccsdesc[500]{General and reference~Empirical studies}

\keywords{Equação do Calor, Diferenças Finitas, Python, Julia, Benchmarking, Docker}

\maketitle

\section{Introdução}
A simulação numérica de fenômenos físicos, como a difusão de calor, é uma tarefa computacionalmente intensiva que exige eficiência tanto do hardware quanto do software. Historicamente, linguagens compiladas como C e Fortran dominam este cenário. No entanto, linguagens de alto nível como Python e Julia ganharam popularidade pela facilidade de desenvolvimento. Este trabalho investiga o trade-off entre facilidade de uso e desempenho, comparando implementações iterativas da Equação do Calor nas duas linguagens.

\section{Metodologia}

\subsection{O Problema Computacional}
A Equação do Calor foi discretizada utilizando o Método das Diferenças Finitas (FDM)\cite{REAMAT} com esquema explícito no tempo. Foram implementados três dimensões:
\begin{itemize}
    \item \textbf{1D:} Complexidade $O(L)$, onde $L$ é o tamanho do domínio linear.
    \item \textbf{2D:} Complexidade $O(L^2)$, representando uma malha quadrada.
    \item \textbf{3D:} Complexidade $O(L^3)$, representando um volume cúbico.
\end{itemize}

\subsection{Design Experimental}
Foi utilizado um projeto fatorial completo considerando os fatores:
\begin{itemize}
    \item \textbf{Linguagem:} Python vs. Julia.
    \item \textbf{Dimensão:} 1D, 2D, 3D.
    \item \textbf{Tamanho do Problema ($L$):} Três níveis (Low, Mid, High) ajustados para cada dimensão para manter tempos de execução mensuráveis.
\end{itemize}
Cada configuração foi executada 30 vezes (`REPLICACOES = 30`) para garantir significância estatística e permitir a análise de variabilidade\cite{Perf-01}\cite{SMPE-01}.

\section{Ambiente e Ferramentas}

\subsection{Hardware e Controle de Ruído}
Para minimizar a interferência do Sistema Operacional e garantir resultados determinísticos, foram aplicadas as seguintes técnicas de controle de ambiente:
\begin{itemize}
    \item \textbf{CPU Pinning:} Os experimentos foram isolados em um núcleo físico específico (`--cpuset-cpus="0"`) via Docker.
    \item \textbf{Frequency Governor:} O governador da CPU foi fixado em \texttt{performance} para evitar oscilações de *clock*.
    \item \textbf{Turbo Boost:} Desativado para mitigar variações térmicas (*thermal throttling*).
    \item \textbf{Inibição de Sistema:} Utilização de \texttt{systemd-inhibit} para prevenir suspensão ou hibernação durante a execução.
\end{itemize}

\subsection{Software e Automação}
O fluxo de trabalho foi totalmente automatizado para garantir reprodutibilidade ("*One script to rule them all*"):
\begin{itemize}
    \item \textbf{Docker:} Contêineres isolados garantiram que as versões das linguagens e bibliotecas fossem idênticas em todas as execuções.
    \item \textbf{Orquestração:} Um makefile que gerenciou a construção da imagem, a geração do plano de execução aleatorizado e a coleta de dados.
    \item \textbf{Análise:} Scripts em R  foram utilizados para processar os logs brutos e gerar visualizações estatísticas.
\end{itemize}

\section{Resultados Finais}

\subsection{Tempo de Execução}
Os resultados indicam uma diferença expressiva de desempenho. A Figura \ref{fig:comparativo} apresenta a distribuição do tempo de execução para as três dimensões.

\begin{figure}[h]
  \centering
  % Substitua pelo caminho real do seu gráfico gerado pelo R
  %\includegraphics[width=0.9\textwidth]{stats/graficos/painel_geral.pdf} 
  \caption{Painel Comparativo de Tempo de Execução (Python vs Julia) para 1D, 2D e 3D.}
  \label{fig:comparativo}
\end{figure}

Os experimentos demonstram que o Julia oferece tempos de resposta substancialmente menores que o Python para a mesma lógica algorítmica. A validação estatística apresentada na Tabela \ref{tab:regressao_tempo} confirma a consistência dos dados: o alto valor de $R^2$ em todos os casos indica que a variação do tempo é explicada quase integralmente pelo aumento do tamanho do problema ($L$), seguindo a complexidade polinomial teórica.

\begin{table}[h]
    \centering
    \caption{Coeficiente de Determinação ($R^2$) para Regressão Linear do Tempo de Execução.}
    \label{tab:regressao_tempo}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Linguagem} & \textbf{Dimensão} & \textbf{$R^2$} & \textbf{$R^2_{adj}$} \\
        \midrule
        Python & 1D & 0.9631 & 0.9627 \\
        Python & 2D & 0.9720 & 0.9717 \\
        Python & 3D & 0.9773 & 0.9771 \\
        \midrule
        Julia & 1D & 0.9924 & 0.9923 \\
        Julia & 2D & 0.9760 & 0.9758 \\
        Julia & 3D & 0.9675 & 0.9671 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Consumo de Memória}
A análise de memória revela o custo do desempenho. A Figura \ref{fig:memoria} e a Tabela \ref{tab:regressao_mem} mostram que o Julia consome consistentemente mais memória RAM que o Python.

\begin{figure}[h]
  \centering
  % Substitua pelo caminho real do seu gráfico de memória
  %\includegraphics[width=0.8\textwidth]{stats/graficos/memoria_perfil/perfil_julia_3d.pdf} 
  \caption{Perfil de consumo de memória para Julia em 3D, evidenciando a alocação estática.}
  \label{fig:memoria}
\end{figure}

\begin{table}[h]
    \centering
    \caption{Regressão Linear: Pico de Memória ($R^2 \approx 1.0$ indica comportamento determinístico).}
    \label{tab:regressao_mem}
    \begin{tabular}{ccc}
        \toprule
        \textbf{Linguagem} & \textbf{Dimensão} & \textbf{$R^2$} \\
        \midrule
        Python & 3D & 0.9661 \\
        Julia & 3D & 0.9667 \\
        \bottomrule
    \end{tabular}
\end{table}

\section{Discussão}

\subsection{Compilação JIT vs Interpretação}
A vantagem massiva do Julia deve-se à sua compilação \textit{Just-In-Time} (JIT) baseada em LLVM. Ao encontrar um laço \texttt{for} tipado, o Julia gera instruções de máquina otimizadas, similares a C/C++. O Python, por sua vez, realiza a verificação de tipos (`type checking`) e o dispatch de métodos dinamicamente a cada iteração do laço, o que introduz um overhead massivo em algoritmos numéricos iterativos ($O(N)$ verificações).

\subsection{Trade-off Memória-Velocidade}
Confirmou-se que não existe opção perfeita. O desempenho superior do Julia exige uma alocação de memória mais agressiva para manter as estruturas de dados e o código compilado. Para sistemas com restrição severa de memória, uma implementação Python otimizada (via C-extensions) poderia ser preferível, apesar da complexidade de desenvolvimento.

\section{Conclusão}

Este estudo demonstrou que, para computação científica baseada em simulações iterativas, a linguagem Julia oferece uma combinação superior de produtividade (sintaxe de alto nível) e desempenho (velocidade de execução), superando Python.

Do ponto de vista metodológico, o trabalho evidenciou que a medição precisa de desempenho em sistemas modernos exige um controle rigoroso do ambiente. O isolamento de processos via Docker e o controle de frequência da CPU foram fundamentais para reduzir o ruído experimental e obter dados consistentes e homescedásticos.

Recomenda-se para trabalhos futuros a exploração de paralelismo (multithreading e GPU) para avaliar se a lacuna de desempenho pode ser reduzida.

%%
%% A bibliografia
\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\end{document}
